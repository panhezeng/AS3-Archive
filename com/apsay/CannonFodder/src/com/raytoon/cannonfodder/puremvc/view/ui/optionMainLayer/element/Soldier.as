///////////////////////////////////////////////////////////
//  Soldier.as
//  Macromedia ActionScript Implementation of the Class Soldier
//  Generated by Enterprise Architect
//  Created on:      16-六月-2011 17:54:37
//  Original author: LuXianli
///////////////////////////////////////////////////////////

package com.raytoon.cannonfodder.puremvc.view.ui.optionMainLayer.element {
	import com.raytoon.cannonfodder.puremvc.view.ui.UIMain;
	import com.raytoon.cannonfodder.puremvc.view.ui.optionMainLayer.OptionMainLayer;
	import com.raytoon.cannonfodder.puremvc.view.ui.optionMainLayer.element.bullet.Bullet;
	import com.raytoon.cannonfodder.puremvc.view.ui.optionMainLayer.element.bullet.BulletRound;
	import com.raytoon.cannonfodder.puremvc.view.ui.optionMainLayer.element.bullet.BulletSputtering;
	import com.raytoon.cannonfodder.puremvc.view.ui.soundLayer.SoundLayer;
	import com.raytoon.cannonfodder.tools.ArticleBlood;
	import com.raytoon.cannonfodder.tools.aStar.Node;
	import com.raytoon.cannonfodder.tools.aStar.RunPoint;
	import com.raytoon.cannonfodder.tools.EventBindingData;
	import com.raytoon.cannonfodder.tools.load.DynamicLoadOriginal;
	import com.raytoon.cannonfodder.tools.load.ElementDead;
	import com.raytoon.cannonfodder.tools.utils.GlobalVariable;
	import com.raytoon.cannonfodder.tools.utils.MapRectInfo;
	import com.raytoon.cannonfodder.tools.utils.UICommand;
	import com.raytoon.cannonfodder.tools.xml.XMLSource;
	import flash.display.Sprite;
	import flash.events.Event;

	import flash.display.MovieClip;
	import flash.display.Shape;
	import flash.events.TimerEvent;
	import flash.geom.ColorTransform;
	import flash.geom.Point;
	import flash.system.ApplicationDomain;
	import flash.utils.Timer;
	import flash.utils.getTimer;

	/**
	 * @author LuXianli
	 * @version 1.0
	 * @created 16-六月-2011 17:54:37
	 */
	public class Soldier extends Element
	{
		//走一格时间 毫秒数
		private var walkTime:int = 1400;
		//士兵的速度
		private var _xSpeed:Number = 0;
		private var _ySpeed:Number = 0;
		private var _xMirrorSpeed:Number = 0;
		private var _yMirrorSpeed:Number = 0;
		private var _speed:Number = 1.5;
		public function set speed(value:int):void {
			if (value == 0) return;
			_speed = value * GlobalVariable.RECT_WIDTH / 150;
			walkTime = Number(GlobalVariable.RECT_WIDTH / _speed) * 1000 / 30;
			if (_mirrorSpeedFlag) {
				_mirrorSpeed = _speed;
				_mirrorSpeedFlag = false;
			}
		}
		public function get speed():int {
			return _speed;
		}
		// 改变移动速度
		override public function elementSpeed(value:Number):void 
		{
			_speed = (1 + value) * _mirrorSpeed;
		}
		//士兵移动类型
		private var _runType:int = 401;
		public function set runType(value:int):void {
			_runType = value;
			moveType = value;
			
			switch (value) {
				
				case 402:
					runFunction = intermittentRun;
					_stopFlag = 2;
				break;
				
				case 403:
					runFunction = jumpRun;
				break;
				
				case 404:
					runFunction = floatingRun;
				break;
				
				case 405:
					runFunction = boringRun;
				break;
			}
			
		}
		
		public function get runType():int {
			return _runType;
		}
		//移动速度备份存储
		private var _mirrorSpeed:Number = 1.5;
		private var _mirrorSpeedFlag:Boolean = true;
		public function set mirrorSpeed(value:Number):void {
			_mirrorSpeed = value;
		}
		public function get mirrorSpeed():Number {
			return _mirrorSpeed;
		}
		
		override public function organDownLife(value:int):void 
		{
			super.downLife(value);
			if (_skills == 304)
				landfill();
		}
		
		private var _transformersFlag:Boolean = true;
		override public function downArmor(value:int):void 
		{
			super.downArmor(value);
			if (_skills == 311 && armor <= 0 && _transformersFlag) {
				_transformersFlag = false;
				transformers();
			}
		}
		//士兵技能
		private var _skills:int = 0;
		private var _skillsRange:Number;
		private var _skillsNum:int;
		private var _skillsValue:int;
		private var _skillsTime:int;
		private var _skillsPercent:Number;
		private var _skillsName:String;
		private var _skillSoundName:String;
		public function set skills(value:int):void {
			_skills = value;
			elementSkills = value;
			var _skillsXmlList:XMLList = XMLSource.getXMLSource("SoldierSkillsInfo.xml").skills.(@id == value);
			_skillsRange = Number(_skillsXmlList.skillsRange);
			_skillsNum = int(_skillsXmlList.skillsNum);
			_skillsValue = int(_skillsXmlList.skillsValue);
			_skillsTime = int(_skillsXmlList.skillsTime);
			_skillsPercent = Number(_skillsXmlList.skillsPercent);
			_skillsName = String(_skillsXmlList.name);
			_skillSoundName = String(_skillsXmlList.skillSound);
			
			_skillsXmlList = null;
			switch(value) {
				
				case 301:
					lgnition();
					break;
					
				case 302:
					ridicule();
					break;
					
				case 304:
					attack = 0;
					break;
					
				case 305:
					swallow();
					break;
					
				case 309:
					attackAble = false;
					mining();
					break;
					
				case 311:
					attack = 0
					break;
			}
		}
		public function get skills():int {
			return _skills;
		}
		public function get skillsRange():Number {
			return _skillsRange;
		}
		public function get skillsNum():int {
			return _skillsNum;
		}
		public function get skillsValue():int {
			return _skillsValue;
		}
		public function get skillsTime():int {
			return _skillsTime;
		}
		public function get skillsPercent():Number {
			return _skillsPercent;
		}
		private var _soldierName:String;
		public function Soldier(soldierName:String,soldierHP:int,soldierArmor:int,level:int = 1){
			super();
			elementLevel = level;
			adType = Element.ATTACK;
			attackElementType = Element.SOLDIER;
			_soldierName = soldierName;
			elementDownLayer = new Sprite();
			addChild(elementDownLayer);
			elementLayer = new Sprite();
			addChild(elementLayer);
			elementUpLayer = new Sprite();
			addChild(elementUpLayer);
			viewUnit = new DynamicLoadOriginal(soldierName,true,"",soldierHP,soldierArmor,soldierHP,soldierArmor,showArticleBlood,10);
			elementLayer.addChild(viewUnit);
			viewUnit.y = 10;
			viewFlag = 1;
			
		}
		/**
		 * 士兵消失
		 */
		private function disappear():void {
			
			x += _speed;
			_showNumber -= 0.01;
			//_shape.scaleX = _showNumber;
			
			if (_showNumber <= 0) {
				(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).passPeopleSum(1);
				(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).removeElement(this);
			}
		}
		private var _shape:Shape;
		private var _showNumber:Number = 1;
		/**
		 * 添加遮罩层
		 */
		private function showMask():void {
			
		}
		
		override public function clear():void 
		{
			super.clear();
			killSkills();
			if (_craterTimer) {
				_craterTimer.reset();
				_craterTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, craterTimerComplete);
				_craterTimer = null;
			}
		}
		/**
		 * 重写单位工作暂停方法
		 * @param	value
		 */
		override public function elementWork(value:Boolean):void 
		{
			super.elementWork(value);
			if (_lgnitionTimer) 
				value ? _lgnitionTimer.start() : _lgnitionTimer.stop();
			
			if (_miningTimer) 
				value ? _miningTimer.start() : _miningTimer.stop();
			
			if (_ridiculeRunTimer)
				value ? _ridiculeRunTimer.start() : _ridiculeRunTimer.stop();
			
			if (_ridiculeTimer)
				value ? _ridiculeTimer.start() : _ridiculeTimer.stop();
			
			if (_swallowTimer)
				value ? _swallowTimer.start() : _swallowTimer.stop();
			
			if (_hurtSpeedTimer)
				value ? _hurtSpeedTimer.start() : _hurtSpeedTimer.stop();
			
			//if (runTimer)
				//value ? runTimer.start() : runTimer.stop();
		}
		
		private var _selfMovie:MovieClip;
		private var _selfClass:Class;
		private var _suffixName:String = "";
		/**
		 * 重写死亡方法
		 * 士兵死亡
		 */
		override public function elementDeath():void 
		{
			if (!deathFlag)
				return;
			deathFlag = false;
			isAlive = false;
			isReady = false;
			running = false;
			if (_skills == 303) {
				_selfClass = ApplicationDomain.currentDomain.getDefinition("SelfExplodeMovie") as Class;
				_selfMovie = new _selfClass() as MovieClip;
				_selfMovie.addFrameScript(_selfMovie.totalFrames - 1, function():void { _selfMovie.stop(); } );
				elementUpLayer.addChild(_selfMovie);
				explosionSelf();
			}else if (_skills == 301) {
				killLgnition();
				//if ((UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).heroRaceID == 2) heroBombHurt();
				elmentDead = new ElementDead(elementDeadName, removeNowElement, removeThis);
				elementLayer.addChild(elmentDead);
				elmentDead.scaleX = _scalxNum;
				elmentDead.y = 10;
				clear();
			}
			else {
				//if ((UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).heroRaceID == 2) heroBombHurt();
				elmentDead = new ElementDead(elementDeadName, removeNowElement, removeThis,_suffixName);
				elementLayer.addChild(elmentDead);
				elmentDead.scaleX = _scalxNum;
				elmentDead.y = 10;
				clear();
			}
			
			removeVenomIcon();
			removeArticleBlood();
			(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).deathPeopleSum( { "dataType":Element.SOLDIER, "dataID":id, "dataSum":1 } , paper);
			(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(deathSound);
			
			if (hurtSum > 0) bombHurt();
		}
		private var _soldierBombHurtMovie:MovieClip;
		/**
		 * 英雄被动技能 伤害  暗黑族 士兵死亡时
		 */
		private function heroBombHurt():void {
			
			var _mClass:Class = ApplicationDomain.currentDomain.getDefinition("SoldierBombHurtMovie") as Class;
			_soldierBombHurtMovie = new _mClass();
			elementUpLayer.addChild(_soldierBombHurtMovie);
			_soldierBombHurtMovie.addFrameScript(_soldierBombHurtMovie.totalFrames - 1, function():void { _soldierBombHurtMovie.stop(); } );
			
			var len:Number = GlobalVariable.RECT_WIDTH * 1.6;
			var towerArr:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).towerArr;
			
			for each (var element:Element in towerArr) {
				
				if (element.elementType != Towers.ENERGY_TOWER && element.elementType != Towers.ORGAN_TOWER && Point.distance(element.position, position) <= len && element.isReady) {
					
					element.downHp((UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).heroRaceNum);
				}
			}
		}
		/**
		 * 炸弹伤害
		 */
		private function bombHurt():void {
			
			var _towerArr:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).towerArr;
			
			for each(var element:Element in _towerArr) {
				if (!element.isReady || element.elementType == Towers.ENERGY_TOWER || element.elementType == Towers.ORGAN_TOWER) continue;
				if (Point.distance(element.position, position) <= hurtRange)
					element.downHp(hurtSum);
			}
			_towerArr = null;
		}
		
		private function killSkills():void {
			
			killLgnition();
			killMining();
			killRidicule();
			killSwallow();
			killHurtSpeed();
			killRun();
		}
		
		private var _shootSum:int = 0;
		/**
		 * 发射子弹攻击 
		 */
		override public function shoot():void {
			if (!(attackAble && isReady) || _skills == 309 || attack <= 0)
				return;
			_shootSum ++;
			if (!target.isReady || target.lifeHP <= 0) {
				target = null;
				return;
			}
			
			if (_skills == 307) {
				
				(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(new BulletSputtering(this, target, bulletEffectName));
			}
			else if (_skills == 301) {
				
				(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(new BulletRound(this));
			}
			else if (_skills == 310) {
				if (!swallowShootFlag) {
					attack *= 5;
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(new Bullet(this, target, "SwallowBullet", attack, _skills));
					attack = mirrorAttack;
					swallowShootFlag = true;
				}else {
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(new Bullet(this, target, bulletEffectName, attack,_skills));
					
				}
			}
			else {
				(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(new Bullet(this, target, bulletEffectName,attack,_skills));
			}
			(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(shootSound);
			//if (_skills == 301 && _shootSum >= 5) {
				//_shootSum = 0;
				//(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(new BulletRound(this));
			//}
		}
		//行走标志位
		private var _runFlag:int = 1;
		public function set runFlag(value:int):void {
			_runFlag = value;
		}
		public function get runFlag():int {
			return _runFlag;
		}
		private var lastShoot:Number = -1;
		public var runFunction:Function = ordinaryRun;//默认的行走函数
		private var _startRunFlag:int = 0;
		private var walkArray:Array = new Array();//行走数组
		private var walkLength:int = 0;
		private var statusRunFlag:Boolean = true;
		private var statusStopFlag:Boolean = true;
		/**
		 * 重新渲染
		 */
		override public function rendering():void 
		{
			if (isHurting)
				elementFlashing();
			if (_runFlag == 1 && _startRunFlag == 0) {
				_startRunFlag = 1;
				runFunction();
				walkArray = runArray;
				walkLength = runArray.length;
			}
			
			if (_runFlag == 1 && running)
				runFunction();
			else if (running)
				disappear();
				
			if (target == null)
				return;
			
			if ((UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).getTargetIndex(target) == -1 || Point.distance(this.position,target.position) > this.maxAttackRange) {
				
				target = null;
				return;
			}
			
			if (lastShoot < 0 || getTimer() - lastShoot > attackHZ) {
				
				shoot();
				lastShoot = getTimer();
			}
			
		}
		//==士兵行走方式=======================================================================
		
		
		override public function get runArray():Array 
		{
			return super.runArray;
		}
		
		override public function set runArray(value:Array):void 
		{
			super.runArray = value;
			optionRunArray(value);
		}
		
		
		//--------------------------------------------------------
		private var _arrFlag:int = 0;
		private var _journey:Number = 0;
		private var _arrLen:int = 0;
		private var _tempArr:Array = [];
		private var _tx:Number = 0;
		private var _ty:Number = 0;
		private function optionRunArray(arr:Array):void {
			
			
			_arrLen = arr.length;
			optionNextPoint();
			
			_tx = _nowX;
			_ty = _nowY;
			
			while (_arrFlag < _arrLen) {
				
				_tx += _xSpeed;
				_ty += _ySpeed;
				
				var runPoint:RunPoint = new RunPoint(_xSpeed, _ySpeed);
				runPoint.x = _tx;
				runPoint.y = _ty;
				
				_tempArr.push(runPoint);
				
				if (Point.distance(new Point(_tx,_ty), new Point(_nowX,_nowY)) >= _journey) {
					
					if (_arrFlag < _arrLen - 1) {
						optionNextPoint();
					}
					else {
						runSiteArray = _tempArr;
						_runSiteLen = _tempArr.length;
						return;
					}
				}
			}
		}
		
		private function optionNextPoint():void {
			
			if (_arrLen > 0) {
				
				_nowX = (runArray[_arrFlag] as Node).unitX;
				_nowY = (runArray[_arrFlag] as Node).unitY;
				
				if (_arrFlag < _arrLen - 1) {
					_nextX = (runArray[_arrFlag + 1] as Node).unitX;
					_nextY = (runArray[_arrFlag + 1] as Node).unitY;
				}else {
					
					return;
				}
				
				//计算需行走直线距离
				_journey = Point.distance(new Point(_nowX,_nowY),new Point(_nextX,_nextY));
				//计算行走角度
				var _bAngle:Number = Math.atan2(_nextY - _nowY, _nextX - _nowX);
				//设定行走 X ，Y 分速度
				_xSpeed = Math.round(_speed * Math.cos(_bAngle)/0.001)*0.001;
				_ySpeed = Math.round(_speed * Math.sin(_bAngle)/0.001)*0.001;
				
				_arrFlag ++;
				
			}
		}
		
		//--------------------------------------------------------
		
		override public function get runSiteArray():Array 
		{
			return super.runSiteArray;
		}
		
		private var _runSiteArr:Array = [];
		private var _runSiteLen:int = 0;
		override public function set runSiteArray(value:Array):void 
		{
			super.runSiteArray = value;
			_runSiteArr = value;
		}
		//刷新行进点-----------------------------------------------
		/**
		 * 
		 * @param	value单位入场时间段
		 */
		override public function refreshRunSite(value:int):void 
		{
			var tmpRunTime:int = value - startTime;
			var _nowSite:int = runSite;
			switch(_runType) {
				
				case 401:
					runSite = tmpRunTime / 1000 * 30;
					if (runSite < runSiteArray.length) {
						x = runSiteArray[runSite].x;
						y = runSiteArray[runSite].y;
					}
					break;
			}
		}
		private function killRun():void {
			
			if (runTimer) {
				if(_runType == 405)
					runTimer.removeEventListener(TimerEvent.TIMER, runTimerRun);
				else
					runTimer.removeEventListener(TimerEvent.TIMER, runTimerRunOne);
				runTimer.stop();
				runTimer = null;
			}
		}
		private var _nowX:int = 0;
		private var _nowY:int = 0;
		private var _nextX:int = 0;
		private var _nextY:int = 0;
		private var walkFlag:int = 0;
		private var _walkDistance:Number = 0;
		
		public static const HERO_WALK_COMPLETE:String = "heroWalkComplete";//英雄到达终点
		private var _enableFlag:Boolean = true;
		private var _row:int = 0;
		private var _num:int = 0;
		/**
		 * 401
		 * 普通行走
		 */
		public function ordinaryRun():void {
			
			if (walkFlag == 0)
				walk();
			
			x += _xSpeed;
			y += _ySpeed;
			
			if (Point.distance(position, new Point(_nowX,_nowY)) >= _walkDistance) {
				if(walkFlag > 0)
					isReady = true;
				if (walkFlag == 1 && _skills == 303) SoundLayer.getInstance().playSound("HaHaSound");
				if (walkFlag < runArray.length - 1) {
					attackAble = true;
					walk();
					
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).removeLayerElement(this);
					row = Math.floor((y - OptionMainLayer.layerHeight) / GlobalVariable.RECT_HEIGHT);
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(this);
					num = Math.floor((x - OptionMainLayer.layerWidth) / GlobalVariable.RECT_WIDTH);
					
					if (revengeTarget) {
						
						if (Point.distance(revengeTarget.position, position) <= revengeTarget.maxAttackRange)
							revengeTarget.shoot();
						else
							revengeTarget = null;
					}
				}
				else {
					
					showMask();
					_runFlag = 0;
					isReady = false;
					attackAble = false;
				}
			}
			
			//if (runSite < _runSiteLen) {
				//
				//x = _runSiteArr[runSite].x;
				//y = _runSiteArr[runSite].y;
				//runSite ++;
				//
				//_row = Math.floor((y - OptionMainLayer.layerHeight) / GlobalVariable.RECT_HEIGHT);
				//_num = Math.floor((x - OptionMainLayer.layerWidth) / GlobalVariable.RECT_WIDTH);
				//
				//if (_row != row) {
					//(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).removeLayerElement(this);
					//row = _row;
					//(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(this);
				//}
				//
				//if (_num != num) num = _num;
				//
			//}else {
				//showMask();
				//isReady = false;
				//attackAble = false;
			//}
			//
			//if (_enableFlag) {
				//
				//if (MapRectInfo.attackRectangle.containsPoint(position)) {
					//
					//_enableFlag = false;
					//isReady = true;
					//attackAble = true;
					//if (_skills == 303) SoundLayer.getInstance().playSound("HaHaSound");
				//}
			//}
		}
		/**
		 * 行走阶段路径计算
		 */
		private function walk():void {
			
			if (runArray.length > 0) {
				
				_nowX = (runArray[walkFlag] as Node).unitX;
				_nowY = (runArray[walkFlag] as Node).unitY;
				x = _nowX;
				y = _nowY;
				if (walkFlag < walkLength - 1) {
					_nextX = (runArray[walkFlag + 1] as Node).unitX;
					_nextY = (runArray[walkFlag + 1] as Node).unitY;
				}else {
					
					return;
				}
				if (_nextX - _nowX > 0) {
					if (viewFlag == 1)
						viewUnit.scaleX = 1;
						_scalxNum = 1;
				}else if (_nextX - _nowX < 0){
					if (viewFlag == 1)
						viewUnit.scaleX = -1;
						_scalxNum = -1;
				}
					
				//计算需行走直线距离
				_walkDistance = Point.distance(new Point(_nowX,_nowY),new Point(_nextX,_nextY));
				//计算行走角度
				var _bAngle:Number = Math.atan2(_nextY - _nowY, _nextX - _nowX);
				//设定行走 X ，Y 分速度
				_xSpeed = Math.round(_speed * Math.cos(_bAngle)/0.001)*0.001;
				_ySpeed = Math.round(_speed * Math.sin(_bAngle)/0.001)*0.001;
				_xMirrorSpeed = Math.round(_mirrorSpeed * Math.cos(_bAngle)/0.001)*0.001;
				_yMirrorSpeed = Math.round(_mirrorSpeed * Math.sin(_bAngle)/0.001)*0.001;
				
				walkFlag ++;
				
			}
		}
		private var runTimer:Timer;
		private var _stopFlag:int = 0;
		/**
		 * 402
		 * 间断行走
		 */
		public function intermittentRun():void {
			
			if (_stopFlag%3 != 0) {
				
				if (walkFlag == 0)
					walk();
				
				if (statusRunFlag) {
					
					statusRunFlag = false;
					statusStopFlag = true;
					attackAble = true;
					if (viewFlag == 1)
						viewUnit.showFrame(1);
					armor = 0;
					mirrorArmor = 0;
					showPlusHPFlag = false;
					if (backHP - _skillsValue >= 0) backHP -= _skillsValue;
					else backHP = 0;
					if (_articlBlood)
						_articlBlood.showArticle(lifeHP, mirrorHP,armor,mirrorArmor);
				}
				x += _xSpeed;
				y += _ySpeed;
				
				if (Point.distance(position, new Point(_nowX,_nowY)) >= _walkDistance) {
					if(walkFlag > 0)
						isReady = true;
					if (walkFlag < runArray.length - 1) {
						if (isReady)
							_stopFlag ++;
						else
							_stopFlag --;
						walk();
						
						(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).removeLayerElement(this);
						row = Math.floor((y - OptionMainLayer.layerHeight) / GlobalVariable.RECT_HEIGHT);
						(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(this);
						num = Math.floor((x - OptionMainLayer.layerWidth) / GlobalVariable.RECT_WIDTH);
					}else {
						
						showMask();
						_runFlag = 0;
						isReady = false;
						attackAble = false;
						
					}
				}
			}else {
				
				if (statusStopFlag) {
					
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).removeLayerElement(this);
					row = Math.floor((y - OptionMainLayer.layerHeight) / GlobalVariable.RECT_HEIGHT);
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(this);
					num = Math.floor((x - OptionMainLayer.layerWidth) / GlobalVariable.RECT_WIDTH);
					
					runTimer = new Timer(walkTime*3, 1);
					runTimer.addEventListener(TimerEvent.TIMER, runTimerRunOne);
					runTimer.start();
					statusStopFlag = false;
					statusRunFlag = true;
					if (viewFlag == 1)
						viewUnit.showFrame(3);
					armor += _skillsNum;
					mirrorArmor = armor;
					showPlusHPFlag = true;
					backHP += _skillsValue;
					if (_articlBlood)
						_articlBlood.showArticle(lifeHP, mirrorHP,armor,mirrorArmor);
				}
				
			}
			
		}
		
		private function runTimerRunOne(event:TimerEvent):void {
			_stopFlag ++;
			runTimer.removeEventListener(TimerEvent.TIMER, runTimerRunOne);
			runTimer.stop();
			runTimer = null;
		}
		
		/**
		 * 403
		 * 跳跃行走
		 */
		public function jumpRun():void {
			
			if (walkFlag == 0)
				jumpWalk();
			
			x += _xSpeed;
			y += _ySpeed;
			
			if (Point.distance(position, new Point(_nowX,_nowY)) >= _walkDistance) {
				
				if (walkFlag < runArray.length - 1) {
					attackAble = true;
					jumpWalk();
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).removeLayerElement(this);
					row = Math.floor((y - OptionMainLayer.layerHeight) / GlobalVariable.RECT_HEIGHT);
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(this);
					num = Math.floor((x - OptionMainLayer.layerWidth) / GlobalVariable.RECT_WIDTH);
				}else {
					
					showMask();
					_runFlag = 0;
					
				}
			}
		}
		/**
		 * 跳跃行走路径计算
		 */
		private function jumpWalk():void {
			
			if (runArray.length > 0) {
				
				_nowX = (runArray[walkFlag] as Node).unitX;
				_nowY = (runArray[walkFlag] as Node).unitY;
				x = _nowX;
				y = _nowY;
				if (walkFlag < runArray.length - 1) {
					_nextX = (runArray[walkFlag + 1] as Node).unitX;
					_nextY = (runArray[walkFlag + 1] as Node).unitY;
				}else {
					showMask();
					_runFlag = 0;
					
					return;
				}
				
				//计算需行走直线距离
				_walkDistance = Point.distance(new Point(_nowX,_nowY),new Point(_nextX,_nextY));
				//计算行走角度
				var _bAngle:Number = Math.atan2(_nextY - _nowY, _nextX - _nowX);
				//设定行走 X ，Y 分速度
				_xSpeed = _speed * Math.cos(_bAngle);
				_ySpeed = _speed * Math.sin(_bAngle);
				_xMirrorSpeed = _mirrorSpeed * Math.cos(_bAngle);
				_yMirrorSpeed = _mirrorSpeed * Math.sin(_bAngle);
				if(walkFlag > 0)
					isReady = true;
				walkFlag += 3;
			}
		}
		/**
		 * 404
		 * 浮游行走
		 */
		public function floatingRun():void {
			
			if (walkFlag == 0)
				floatingWalk();
			
			x += _xSpeed;
			y += _ySpeed;
			num = Math.floor((x - OptionMainLayer.layerWidth) / GlobalVariable.RECT_WIDTH);
			if (!isReady) {
				if (MapRectInfo.attackRectangle.containsPoint(position))
					isReady = true;
			}
			
			if (Point.distance(position, new Point(_nowX, _nowY)) >= _walkDistance) {
				showMask();
				_runFlag = 0;
				isReady = false;
				attackAble = false;
				
			}
			
		}
		
		private function floatingWalk():void {
			
			if (runArray.length > 0) {
				
				_nowX = (runArray[walkFlag] as Node).unitX;
				_nowY = (runArray[walkFlag] as Node).unitY;
				x = _nowX;
				y = _nowY;
				_nextX = (runArray[runArray.length - 1] as Node).unitX;
				_nextY = (runArray[runArray.length - 1] as Node).unitY;
				
				//计算需行走直线距离
				_walkDistance = Point.distance(new Point(_nowX,_nowY),new Point(_nextX,_nextY));
				//计算行走角度
				var _bAngle:Number = Math.atan2(_nextY - _nowY, _nextX - _nowX);
				//设定行走 X ，Y 分速度
				_xSpeed = _speed * Math.cos(_bAngle);
				_ySpeed = _speed * Math.sin(_bAngle);
				_xMirrorSpeed = _mirrorSpeed * Math.cos(_bAngle);
				_yMirrorSpeed = _mirrorSpeed * Math.sin(_bAngle);
				walkFlag ++;
			}
		}
		/**
		 * 405
		 * 钻地行走
		 */
		public function boringRun():void {
			
			if (_stopFlag < 5) {
				//isReady = true;
				//attackAble = false;
				if (walkFlag == 0)
					walk();
				if (statusRunFlag) {
					isReady = true;
					attackAble = false;
					statusRunFlag = false;
					statusStopFlag = true;
					if (viewFlag == 1)
						viewUnit.showFrame(1);
				}
				x += _xSpeed;
				y += _ySpeed;
				
				if (Point.distance(position, new Point(_nowX,_nowY)) >= _walkDistance) {
					
					if (walkFlag < runArray.length - 1) {
						
						_stopFlag ++;
						walk();
						
						(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).removeLayerElement(this);
						row = Math.floor((y - OptionMainLayer.layerHeight) / GlobalVariable.RECT_HEIGHT);
						(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(this);
						num = Math.floor((x - OptionMainLayer.layerWidth) / GlobalVariable.RECT_WIDTH);
					}else {
						
						showMask();
						_runFlag = 0;
						isReady = false;
						attackAble = false;
						
					}
				}
			}else {
				
				if (statusStopFlag) {
					
					runTimer = new Timer(walkTime, 1);
					runTimer.addEventListener(TimerEvent.TIMER, runTimerRun);
					runTimer.start();
					statusStopFlag = false;
					statusRunFlag = true;
					if (viewFlag == 1)
						viewUnit.showFrame(3);
					attackAble = true;
					//isReady = true;
				}
				
			}
			
		}
		private function runTimerRun(event:TimerEvent):void {
			
			_stopFlag = 0;
			runTimer.removeEventListener(TimerEvent.TIMER, runTimerRun);
			runTimer.stop();
			runTimer = null;
		}
		//==================钻地行走备份==================
		//public function boringRun():void {
			//
			//if (walkFlag == 0)
				//walk();
			//
			//x += _xSpeed;
			//y += _ySpeed;
			//
			//if (Point.distance(position, new Point(_nowX, _nowY)) >= _walkDistance) {
				//
				//if (walkFlag < runArray.length - 1) {
					//
					//walk();
					//if (walkFlag % 3 == 2) {
						//
						//if (viewUnit.getFrame() != 2) {
							//isReady = false;
							//viewUnit.showFrame(1);
						//}
						//attackAble = false;
						//
					//}else {
						//
						//isReady = true;
						//viewUnit.showFrame(3);
						//attackAble = true;
						//
					//}
				//}else {
					//
					//showMask();
					//_runFlag = 0;
					//dispatchEvent(new EventBindingData(HERO_WALK_COMPLETE,this));
				//}
			//}
		//}
		
		//技能伤害速度时调用=============================================================================
		
		private var _hurtSpeedTimer:Timer;
		private var _hurtSpeedFlag:Boolean = true;
		
		override public function hurtSpeed(_hurtSpeed:Number = 0.2,_hurtSpeedTime:int = 3):void {
			
			if (_hurtSpeedFlag) {
				
				_hurtSpeedFlag = false;
				_speed *= (1 - _hurtSpeed);
				_xSpeed *= (1 - _hurtSpeed);
				_ySpeed *= (1 - _hurtSpeed);
				_hurtSpeedTimer = new Timer(_hurtSpeedTime * 1000, 1);
				_hurtSpeedTimer.addEventListener(TimerEvent.TIMER, hurtSpeedTimerHandler);
				_hurtSpeedTimer.start();
				if (viewFlag == 1){
					viewUnit.transform.colorTransform = new ColorTransform(1, 1, 1, 1, 0, 20, 230, 0);
					
				}
			}else {
				if (_hurtSpeedTimer) {
					
					_hurtSpeedTimer.reset();
					_hurtSpeedTimer.start();
				}
			}
		}
		
		private function hurtSpeedTimerHandler(event:TimerEvent):void {
			
			if (!_hurtSpeedFlag) {
				if (_skills == 306) {
					if (viewFlag == 1) {
						_redNum = 255 - lifeHP / mirrorHP * 255;
						viewUnit.transform.colorTransform = new ColorTransform(1, 1, 1, 1, _redNum, 0, 0, 0);
					}
				}else {
					
					if (viewFlag == 1)
						viewUnit.transform.colorTransform = new ColorTransform();
				}
				_speed = _mirrorSpeed;
				_xSpeed = _xMirrorSpeed;
				_ySpeed = _yMirrorSpeed;
				if (_hurtSpeedTimer) {
					
					_hurtSpeedTimer.removeEventListener(TimerEvent.TIMER, hurtSpeedTimerHandler);
					_hurtSpeedTimer.reset();
					_hurtSpeedTimer = null;
				}
				_hurtSpeedFlag = true;
			}
		}
		
		private function killHurtSpeed():void {
			
			if (_hurtSpeedTimer) {
				
				_hurtSpeedTimer.removeEventListener(TimerEvent.TIMER, hurtSpeedTimerHandler);
				_hurtSpeedTimer.reset();
				_hurtSpeedTimer = null;
			}
		}
		
		//士兵技能 引燃 301 ==================================================================
		
		private var _lgnitionTimer:Timer;
		
		private function lgnition():void {
			
			_lgnitionTimer = new Timer(5000);
			_lgnitionTimer.addEventListener(TimerEvent.TIMER, lgnitionTimerhandler);
			_lgnitionTimer.start();
			
		}
		
		private function lgnitionTimerhandler(event:TimerEvent):void {
			
			var _towerArray:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).towerArr;
			//(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(_skillSoundName);
			var _lignitionLen:Number = GlobalVariable.RECT_WIDTH * _skillsRange;
			for each(var element:Element in _towerArray) {
				if (element.elementType != Towers.DEFENCE_TOWER) continue;
				if (Point.distance(element.position, position) <= _lignitionLen ) {
					
					if(element.lifeHP > 0)element.hurtBackHp(_skillsValue, _skillsTime);
				}
			}
			_towerArray = null;
		}
		
		private function killLgnition():void {
			
			if (_lgnitionTimer) {
				
				_lgnitionTimer.reset();
				_lgnitionTimer.removeEventListener(TimerEvent.TIMER, lgnitionTimerhandler);
				_lgnitionTimer = null;
			}
		}
		
		//士兵技能  嘲讽 302 ==================================================================
		
		private var _ridiculeTimer:Timer;
		private function ridicule():void {
			
			_ridiculeTimer = new Timer(_skillsTime * 1000);
			_ridiculeTimer.addEventListener(TimerEvent.TIMER, ridiculeTimerHandler);
			_ridiculeTimer.start();
		}
		
		private var _ridiculeRunTimer:Timer;
		private function ridiculeTimerHandler(event:TimerEvent):void {
			
			if (viewFlag == 1)
				elementLayer.removeChild(viewUnit);
			viewFlag = 0;
			viewUnit = null;
			viewUnit = new DynamicLoadOriginal(_soldierName + "JuPai",true,"",lifeHP,armor,mirrorHP,mirrorArmor);
			elementLayer.addChild(viewUnit);
			viewUnit.y = 10;
			viewFlag = 1;
			viewUnit.scaleX = _scalxNum;
			attackPriority = 10;
			(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(_skillSoundName);
			OptionMainLayer.ATTACK_ONLY_FLAG = 1;
			_ridiculeRunTimer = new Timer(5000, 1);
			_ridiculeRunTimer.addEventListener(TimerEvent.TIMER, ridiculeRunTimerhandler);
			_ridiculeRunTimer.start();
		}
		
		private function ridiculeRunTimerhandler(event:TimerEvent):void {
			
			attackPriority = mirrorAttackPriorty;
			OptionMainLayer.ATTACK_ONLY_FLAG = 0;
			
			if (viewFlag == 1)
				elementLayer.removeChild(viewUnit);
			viewFlag = 0;
			viewUnit = null;
			viewUnit = new DynamicLoadOriginal(_soldierName,true,"",lifeHP,armor,mirrorHP,mirrorArmor);
			elementLayer.addChild(viewUnit);
			viewUnit.y = 10;
			viewFlag = 1;
			viewUnit.scaleX = _scalxNum;
			_ridiculeRunTimer.removeEventListener(TimerEvent.TIMER, ridiculeRunTimerhandler);
			_ridiculeRunTimer.reset();
			_ridiculeRunTimer = null;
		}
		
		private function killRidicule():void {
			attackPriority = 0;
			OptionMainLayer.ATTACK_ONLY_FLAG = 0;
			if (_ridiculeTimer) {
				_ridiculeTimer.reset();
				_ridiculeTimer.removeEventListener(TimerEvent.TIMER, ridiculeTimerHandler);
				_ridiculeTimer = null;
			}
			if (_ridiculeRunTimer) {
				_ridiculeRunTimer.reset();
				_ridiculeRunTimer.removeEventListener(TimerEvent.TIMER, ridiculeRunTimerhandler);
				_ridiculeRunTimer = null;
			}
		}
		//士兵技能 自爆 303 ================================================
		private var _craterTimer:Timer;
		private var _craterMc:MovieClip;
		private function explosionSelf():void {
			
			(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(_skillSoundName);
			var _towerArray:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).towerArr;
			var _selfLen:Number = GlobalVariable.RECT_WIDTH * _skillsRange;
			for each(var element:Element in _towerArray) {
				if (!element.isReady || element.elementType == Towers.ENERGY_TOWER || element.elementType == Towers.ORGAN_TOWER) continue;
				if (Point.distance(element.position, position) < _selfLen)
					element.downHp(_skillsValue);
			}
			
			removeFireHurtMovie();
			var _craterClass:Class = ApplicationDomain.currentDomain.getDefinition("BulletCrater") as Class;
			_craterMc = new _craterClass() as MovieClip;
			elementDownLayer.addChild(_craterMc);
			_craterMc.y = 10;
			_craterClass = null;
			(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).removeLayerElement(this);
			row = 0;
			(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(this);
			
			(UIMain.getInstance(UIMain.NAME) as UIMain).shakeStage();
			elmentDead = new ElementDead(elementDeadName, removeNowElement,null,"",100);
			elementLayer.addChild(elmentDead);
			elmentDead.scaleX = _scalxNum;
			elmentDead.y = 10;
			
			_selfLen = GlobalVariable.RECT_WIDTH;
			for each(var telement:Element in _towerArray) {
				
				if (Point.distance(telement.position, position) < _selfLen) {
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).removeLayerElement(telement);
					
					(UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).addElement(telement);
				}
				
			}
			
			_towerArray = null;
			if (!_craterTimer) {
				
				_craterTimer = new Timer(20000, 1);
				_craterTimer.addEventListener(TimerEvent.TIMER_COMPLETE, craterTimerComplete);
				_craterTimer.start();
			}
		}
		
		private function craterTimerComplete(event:TimerEvent):void {
			
			clear();
			elementDownLayer.removeChild(_craterMc);
			_craterMc = null;
			elementLayer.removeChild(elmentDead);
			elmentDead = null;
			elmentDead = new ElementDead("BulletCrater", removeNowElement,removeThis);
			elementLayer.addChild(elmentDead);
			elmentDead.y = 10;
		}
		
		//士兵技能  填埋 304 =============================================
		private var _landfillFlag:Boolean = true;
		private function landfill():void {
			
			if (!_landfillFlag)
				return;
			_landfillFlag = false;
			(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(_skillSoundName);
			var _towerArray:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).towerArr;
			var _selfLen:int = GlobalVariable.RECT_WIDTH / 2;
			var _landMovieFlag:Boolean = false;
			for each(var element:Element in _towerArray) {
				
				if (Point.distance(element.position, position) < _selfLen) {
					
					if (element.id != "602" && element.elementType == Towers.ORGAN_TOWER && element.isReady) {
						
						element.showDeathMovie();
						_landMovieFlag = true;
						break;
					}
				}
				
			}
			_towerArray = null;
			if (_landMovieFlag) showLandMovie();
			else _landfillFlag = true;
		}
		
		private var _landfillDrillMovie:MovieClip;
		private function showLandMovie():void {
			
			if (viewUnit) {
				viewFlag = 0;
				elementLayer.removeChild(viewUnit);
				viewUnit = null;
				viewUnit = new DynamicLoadOriginal(_soldierName + "ShiXiao",OptionMainLayer.viewArticleBloodFlag,"",lifeHP,armor,mirrorHP,mirrorArmor);
				elementLayer.addChild(viewUnit);
				viewUnit.y = 10;
				viewUnit.scaleX = _scalxNum;
				viewFlag = 1;
				_suffixName = "ShiXiao";
				attack =  int(XMLSource.getXMLSource("SoldierLevelInfo.xml").soldierLevel.(@id == id).level.(@grade == elementLevel).attack);
				if (!_landfillDrillMovie) {
					
					var _mClass:Class = ApplicationDomain.currentDomain.getDefinition("LandfillDrillMovie") as Class;
					_landfillDrillMovie = new _mClass() as MovieClip;
					elementUpLayer.addChild(_landfillDrillMovie);
					_landfillDrillMovie.y = 10;
					_landfillDrillMovie.addFrameScript(_landfillDrillMovie.totalFrames - 1, function():void { _landfillDrillMovie.stop(); } );
					_mClass = null;
				}
			}
		}
		
		//士兵技能 吞噬 305 ================================================
		
		private var _swallowTimer:Timer
		private function swallow():void {
			
			_swallowTimer = new Timer(_skillsTime * 1000);
			_swallowTimer.addEventListener(TimerEvent.TIMER, swallowTimerHanler);
			_swallowTimer.start();
		}
		
		private function swallowTimerHanler(event:TimerEvent):void {
			
			var _soldierArray:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).soldierArr;
			var _selfLen:Number = GlobalVariable.RECT_WIDTH * _skillsRange;
			(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(_skillSoundName);
			var _soldierElement:Element;
			
			for each (var element:Element in _soldierArray) {
				
				if (_soldierElement && element.percentHp < _skillsPercent && element != this) {
					
					if (_soldierElement.percentHp > element.percentHp && Point.distance(position,element.position) < _selfLen)
						_soldierElement = element;
				}else if (element.percentHp < _skillsPercent && element != this && Point.distance(position,element.position) < _selfLen) {
					
					_soldierElement = element;
				}
			}
			_soldierArray = null;
			if (_soldierElement) {
				showSwallowMovie();
				_soldierElement.elementDeath();
				plusHp(_skillsValue);
			}
			_soldierArray = null;
		}
		
		private var _swallowMovie:MovieClip;
		private var _swallowClass:Class;
		private var _swallowFlag:Boolean = true;
		private function showSwallowMovie():void {
			
			if (_swallowFlag) {
				_swallowFlag = false;
				_swallowClass = ApplicationDomain.currentDomain.getDefinition("SwallowMovie") as Class;
				_swallowMovie = new _swallowClass() as MovieClip;
				_swallowMovie.addFrameScript(_swallowMovie.totalFrames - 1, function ():void { _swallowMovie.stop(); } );
				elementUpLayer.addChild(_swallowMovie);
			}else {
				if (_swallowMovie)
					_swallowMovie.play();
			}
		}
		
		private var _swallowSoldierMovie:MovieClip;
		private var _swallowSoldierClass:Class;
		private var _swallowSoldierFlag:Boolean = true;
		private function showSwallowSoldierMovie():void {
			
			if (_swallowSoldierFlag) {
				_swallowSoldierFlag = false;
				_swallowSoldierClass = ApplicationDomain.currentDomain.getDefinition("SwallowSoldierMovie") as Class;
				_swallowSoldierMovie = new _swallowSoldierClass() as MovieClip;
				_swallowSoldierMovie.addFrameScript(_swallowSoldierMovie.totalFrames - 1, function():void { _swallowSoldierMovie.stop(); removeThis(); } );
				elementUpLayer.addChild(_swallowSoldierMovie);
				_swallowSoldierClass = null;
				SoundLayer.getInstance().playSound("BathSound");
			}
		}
		
		private function killSwallow():void {
			
			if (_swallowTimer) {
				
				_swallowTimer.reset();
				_swallowTimer.removeEventListener(TimerEvent.TIMER, swallowTimerHanler);
				_swallowTimer = null;
			}
			
			if (!_swallowFlag) {
				
				elementUpLayer.removeChild(_swallowMovie);
				_swallowMovie = null;
				_swallowClass = null;
				_swallowFlag = true;
			}
		}
		//士兵技能 无畏 306 =====================================================
		private var _redNum:int;
		override public function downHp(value:int):void 
		{
			super.downHp(value);
			
			if (_skills == 306) {
				if (mirrorHP == 0) return;
				(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(_skillSoundName);
				_redNum = 255 - lifeHP / mirrorHP * 255;
				attack = mirrorAttack + (1 - lifeHP / mirrorHP) * _skillsNum;
				if (viewFlag == 1) 
					viewUnit.transform.colorTransform = new ColorTransform(1, 1, 1, 1, _redNum, 0, 0, 0);
				
			}
			else if (_skills == 311 && armor <= 0) {
				transformers();
			}
		}
		
		//士兵技能 开矿 309 =======================================================
		
		private var _miningTimer:Timer;
		private function mining():void {
			
			_miningTimer = new Timer(600);
			_miningTimer.addEventListener(TimerEvent.TIMER, miningTimerHandler);
			_miningTimer.start();
		}
		
		private var _oreChangeMovie:MovieClip;
		private function miningTimerHandler(event:TimerEvent):void {
			
			var _towerArray:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).towerArr;
			var _selfLen:int = GlobalVariable.RECT_HEIGHT / 2;
			for each(var element:Element in _towerArray) {
				
				if (element.elementSkills == 211 && Point.distance(position, element.position) < _selfLen && element.makeGlodFlag) {
					isReady = false;
					element.makeGlod();
					if (_miningTimer) {
						
						_miningTimer.reset();
						_miningTimer.removeEventListener(TimerEvent.TIMER, miningTimerHandler);
						_miningTimer = null;
					}
					var _mClass:Class = ApplicationDomain.currentDomain.getDefinition("OreChangeMovie") as Class;
					_oreChangeMovie = new _mClass() as MovieClip;
					_oreChangeMovie.addFrameScript(_oreChangeMovie.totalFrames - 1, function():void { _oreChangeMovie.stop(); removeThis(); } );
					(UIMain.getInstance(UIMain.NAME) as UIMain).addChild(_oreChangeMovie);
					_oreChangeMovie.x = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).paperPoint.x;
					_oreChangeMovie.y = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).paperPoint.y;
					if (OptionMainLayer._skillsButtonFlag) {
						
						UICommand.setPaperNum((UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).firstOrePaper);
					}
					_towerArray = null;
					(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(_skillSoundName);
					(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound("OhYearSound");
					return;
				}
			}
			_towerArray = null;
			if (!isReady)
				return;
			var _attackArr:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).attackArr;
			for each(var offerSoldier:Element in _attackArr) {
				
				if (offerSoldier.elementSkills == 310 && offerSoldier.isReady && offerSoldier.swallowShootFlag) {
					offerSoldier.swallowShootFlag = false;
					offerSoldier.offerings(lifeHP);
					showSwallowSoldierMovie();
					_attackArr = null;
					return;
				}
			}
			_attackArr = null;
		}
		
		private function killMining():void {
			
			if (_miningTimer) {
				
				_miningTimer.reset();
				_miningTimer.removeEventListener(TimerEvent.TIMER, miningTimerHandler);
				_miningTimer = null;
			}
		}
		
		override public function removeThis(...args):void 
		{
			if (_oreChangeMovie) {
				(UIMain.getInstance(UIMain.NAME) as UIMain).removeChild(_oreChangeMovie);
				_oreChangeMovie = null;
			}
			super.removeThis();
		}
		//技能 310 新吞噬 =============================================================================
		private var _offeringsFlag:Boolean = true;
		override public function offerings(value:int = 100):void 
		{
			showSwallowMovie();
			(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(_skillSoundName);
			//_offeringsFlag = false;
		}
		
		//手纸动画，英雄技能调用===========================================================
		
		private var _paperMovie:MovieClip;
		public function showPaperMovie():void {
			
			if (!_paperMovie) {
				
				var _mClass:Class = ApplicationDomain.currentDomain.getDefinition("HeroSkillsGiftMovie") as Class;
				_paperMovie = new _mClass() as MovieClip;
				elementUpLayer.addChild(_paperMovie);
				_mClass = null;
				_paperMovie.addFrameScript(_paperMovie.totalFrames - 1, function():void { _paperMovie.stop(); } );
				
			}else {
				if (_paperMovie)
					_paperMovie.gotoAndPlay(1);
			}
			
		}
		
		//技能 311   变形金刚===========================================================================
		
		private var _transformersMovie:MovieClip;
		public function transformers():void {
			(UIMain.getInstance(SoundLayer.NAME) as SoundLayer).playSound(_skillSoundName);
			var _sXmlList:XMLList = XMLSource.getXMLSource("SoldierInfo.xml").soldier.(@id == _skillsValue);
			elementDeadName = String(_sXmlList.deathName);
			attack = int(XMLSource.getXMLSource("SoldierLevelInfo.xml").soldierLevel.(@id == id).level.(@grade == elementLevel).attack);
			removeArticleBlood();
			if (viewFlag == 1) {
				viewFlag = 0;
				elementLayer.removeChild(viewUnit);
				viewUnit = null;
				viewUnit = new DynamicLoadOriginal(String(_sXmlList.name),OptionMainLayer.viewArticleBloodFlag,"",lifeHP,armor,mirrorHP,mirrorArmor,showArticleBlood,10);
				elementLayer.addChild(viewUnit);
				viewUnit.y = 10;
				viewUnit.scaleX = _scalxNum;
				viewFlag = 1;
			}
			if (!_transformersMovie) {
				
				var _mClass:Class = ApplicationDomain.currentDomain.getDefinition(_skillsName) as Class;
				_transformersMovie = new _mClass() as MovieClip;
				elementUpLayer.addChild(_transformersMovie);
				_transformersMovie.addFrameScript(_transformersMovie.totalFrames - 1, function():void { _transformersMovie.stop(); } );
				_mClass = null;
			}
			_sXmlList = null;
		}
		
		// 技能 318  魔传输 =========================================================================
		
		private function transmission():void {
			
			
		}
	}//end Soldier

}