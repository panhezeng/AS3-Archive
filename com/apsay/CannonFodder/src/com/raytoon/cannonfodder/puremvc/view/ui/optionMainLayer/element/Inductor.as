///////////////////////////////////////////////////////////
//  Inductor.as
//  Macromedia ActionScript Implementation of the Class Inductor
//  Generated by Enterprise Architect
//  Created on:      27-六月-2011 10:54:41
//  Original author: LuXianli
///////////////////////////////////////////////////////////

package com.raytoon.cannonfodder.puremvc.view.ui.optionMainLayer.element
{
	import com.raytoon.cannonfodder.puremvc.view.ui.optionMainLayer.OptionMainLayer;
	import com.raytoon.cannonfodder.puremvc.view.ui.UIMain;
	import flash.events.Event;
	import flash.events.TimerEvent;
	import flash.geom.Point;
	import flash.utils.Timer;
	/**
	 * @author LuXianli
	 * @version 1.0
	 * @created 27-六月-2011 10:54:41
	 */
	public class Inductor
	{
		public function Inductor(){

		}
		//设定防守对象
		private var _defendElement:Element;
		public function set defendElement(value:Element):void {
			_defendElement = value;
		}
		public function get defendElement():Element {
			return _defendElement;
		}
		//设定攻击对象
		private var _attackElement:Element;
		public function set attackElement(value:Element):void {
			_attackElement = value;
		}
		public function get attackElement():Element {
			return _attackElement;
		}
		private var getDefendArr:Array;
		/**
		 * 圆形或环形攻击范围
		 * 攻击方获取防守方最近攻击目标
		 */
		public function getDefendElement():void {
			
			getDefendArr = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).towerArr;
			for each(var element:Element in getDefendArr) {
				
				if (Point.distance(element.position, attackElement.position) <= attackElement.maxAttackRange && Point.distance(element.position,attackElement.position) >= attackElement.minAttackRange && element.isReady && element.elementType != Towers.ORGAN_TOWER) {
					
					if (attackElement.target) {
						if (Point.distance(attackElement.position, attackElement.target.position) > Point.distance(attackElement.position, element.position))
							attackElement.target = element;
					}else {
						attackElement.target = element;
					}
				}
			}
			
			getDefendArr = null;
		}
		private var getAttackArr:Array;
		/**
		 * 圆形或环形攻击范围
		 * 防守方获取攻击方最近攻击目标
		 */
		public function getAttackElement():void {
			
			getAttackArr = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).attackArr;
			for each(var element:Element in getAttackArr) {
				if (!element.isReady) continue;
				if (Point.distance(element.position, defendElement.position) <= defendElement.maxAttackRange && Point.distance(element.position,defendElement.position) >= defendElement.minAttackRange) {
					
					if ((defendElement as Towers).attackType == 5) {
						
						if (defendElement.row == element.row || defendElement.num == element.num) {
							defendElement.target = element;
							defendElement.shoot();
						}
					}else {
						
						if (defendElement.target) {
							if (defendElement.target.attackPriority < element.attackPriority) {
								defendElement.target = element;
								defendElement.shoot();
							}
						}else {
							defendElement.target = element;
							defendElement.shoot();
						}
					}
					
				}
			}
			
			defendElement = null;
			getAttackArr = null;
		}
		
		//单位 属性 加成 控制====================================================================================================================================
		
		//加成回血速度
		private var _additionBackHpTimeTimer:Timer;
		private var _additionBackHpFlag:int = 0;
		private var _additionBackHpTime:Number = 0;
		public function additionElementBackHpTime(value:Number):void {
			
			_additionBackHpTime = value;
			_additionBackHpFlag ++;
			if (!_additionBackHpTimeTimer) {
				
				_additionBackHpTimeTimer = new Timer(5000);
				_additionBackHpTimeTimer.addEventListener(TimerEvent.TIMER, additionBackHpTimeTimerHandler);
				_additionBackHpTimeTimer.start();
			}
		}
		
		private function additionBackHpTimeTimerHandler(event:TimerEvent):void {
			
			var _attackArray:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).attackArr;
			
			for each(var element:Element in _attackArray) {
				
				element.additionBackHpTime(_additionBackHpTime);
			}
			
			_attackArray = null;
		}
		
		public function cancelAdditionBackHpTime():void {
			
			if (_additionBackHpFlag <= 0 && _additionBackHpTimeTimer) {
				
				_additionBackHpTimeTimer.reset();
				_additionBackHpTimeTimer.removeEventListener(TimerEvent.TIMER, additionBackHpTimeTimerHandler);
				_additionBackHpTimeTimer = null;
				_additionBackHpTime = 0;
				additionBackHpTimeTimerHandler(null);
				return;
			}
			_additionBackHpFlag --;
		}
		
		//加成 攻击力
		
		private var _additionAttackTimer:Timer;
		private var _additionAttackFlag:int = 0;
		private var _additionAttack:Number = 0;
		
		public function additionElementAttack(value:Number):void {
			
			_additionAttack = value;
			_additionAttackFlag ++;
			if (!_additionAttackTimer) {
				
				_additionAttackTimer = new Timer(5000);
				_additionAttackTimer.addEventListener(TimerEvent.TIMER, additionAttackTimerHandler);
				_additionAttackTimer.start();
			}
		}
		
		private function additionAttackTimerHandler(event:TimerEvent):void {
			
			var _attackArray:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).attackArr;
			
			for each(var element:Element in _attackArray) {
				
				element.additionAttack(_additionAttack);
			} 
			
			_attackArray = null;
		}
		
		public function cancelAdditionAttack():void {
			
			if (_additionAttackFlag <= 0 && _additionAttackTimer) {
				
				_additionAttackTimer.reset();
				_additionAttackTimer.removeEventListener(TimerEvent.TIMER, additionAttackTimerHandler);
				_additionAttackTimer = null;
				_additionAttack = 0;
				additionAttackTimerHandler(null);
				return;
			}
			_additionAttackFlag --;
		}
		
		//加成  移动 速度
		
		private var _additionSpeedTimer:Timer;
		private var _additionSpeedFlag:int = 0;
		private var _additionSpeed:Number = 0;
		
		public function additionElementSpeed(value:Number):void {
			
			_additionSpeed = value;
			_additionSpeedFlag ++;
			if (!_additionSpeedTimer) {
				
				_additionSpeedTimer = new Timer(5000);
				_additionSpeedTimer.addEventListener(TimerEvent.TIMER, additionSpeedTimerHandler);
				_additionSpeedTimer.start();
			}
		}
		
		private function additionSpeedTimerHandler(event:TimerEvent):void {
			
			var _attackArray:Array = (UIMain.getInstance(OptionMainLayer.NAME) as OptionMainLayer).attackArr;
			
			for each(var element:Element in _attackArray) {
				
				element.elementSpeed(_additionSpeed);
			} 
			
			_attackArray = null;
		}
		
		public function cancelAdditionSpeed():void {
			
			if (_additionSpeedFlag <= 0 && _additionSpeedTimer) {
				
				_additionSpeedTimer.reset();
				_additionSpeedTimer.removeEventListener(TimerEvent.TIMER, additionSpeedTimerHandler);
				_additionSpeedTimer = null;
				_additionSpeed = 0;
				additionSpeedTimerHandler(null);
				return;
			}
			
			_additionSpeedFlag --;
		}
	}//end Inductor

}